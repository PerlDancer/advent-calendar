=encoding utf8

=head1 Medium-Scale Dancer, Part 5: REST APIs and JSON

In previous parts of L<this article series|/2015/3>, I defined each
route handler as a one-liner, like so:

    prefix '/mf' => sub {
        get '' => \&retrieve;
        prefix '/subfeature' => sub {
            get  ''     => \&_get;
            post ''     => \&_post;
            put  ''     => \&_put;
            del  '/:id' => \&_del;
        };
    };

This is very much on purpose, despite the fact that Dancer lets you
define all of the code for each route handler within an anonymous code
reference (e.g. C<sub { ... }>) block. What do we get by moving those
functions elsewhere, and what do we gain that makes it worth tolerating
the ugly C<\&> syntax?

We get two benefits by doing so.

First, named subroutines make stack traces easier to read.

Second, and far more important to our purposes here in this article
series, it makes the URL structure of the web app explicit in the code.

To some extent, you can see this by looking at your app's C<views>
subdirectory, since a prior article in this series encouraged you to map
template files 1:1 to Dancer routes, as much as possible. The problem
with relying on the C<views> directory contents as a document for the
web app's URL structure is that the OS's file system normally shows you
only one layer of the directory hierarchy at a time. You have to go out
of your way to see the whole tree in a compact form, on a single screen.
That means you may never actually find yourself studying the hierarchy
as a whole, and thus may never consider whether it is a cohesive design.

This practice of defining Dancer route handlers as one-liners solves
that. It ensures that every time you adjust the route handlers for your
site, you're doing so while looking at the neighboring routes; you will
be defining new routes in context, not independently. This counteracts
the entropic forces that result in API design drift because it
implicitly encourages you to define new routes that fit logically into
the scheme you defined previously. Without this extra Perl function call
layer, the route definitions are visually broken up, so that you cannot
see the whole design on a single screen. The resulting URL scheme can
turn into a mess, as developers hack on the app over the course of
years.

This is also why I have carefully lined up the blocks and
L<fat commas|https://en.wikipedia.org/wiki/Fat_comma> in the route
definitions: I want patterns in the URL scheme to jump out at me.
Left-justifying everything obscures these patterns.

Now you may be asking, why does all this matter?

The reason is simple: When you make patterns in the URL scheme
graphically apparent, you may discover some previously hidden practical
value that was just sitting there waiting to be exploited. It works for
the same reason that seeing a plot for a numeric data set for the first
time sometimes creates a clear call to action.

It turns out that the example route scheme we've been defining
throughout this article series includes a web API; it's just been
sitting there, waiting to be discovered. With a bit of polishing, it
might even turn into a proper
L<REST|https://en.wikipedia.org/wiki/Representational_state_transfer>
API. Let's try.

Look back up at that route definition block above. What does it remind
you of? If you said
L<CRUD|https://en.wikipedia.org/wiki/Create,_read,_update_and_delete>,
go to the head of the class.

Now, HTTP verbs do not correspond directly to CRUD because HTTP was not
designed to be a CRUD API. There are competing design philosophies when
it comes to mapping HTTP verbs to the CRUD model of persistent data
storage.

I prefer this mapping:

      DB term    | HTTP verb
    +------------+----------
    | C = create | POST
    | R = read   | GET
    | U = update | PUT
    | D = delete | DELETE

The R = C<GET> and D = C<DELETE> rules are obvious, but it may not be
clear to you why the other two rules are correct.

L<The HTTP spec|http://www.w3.org/Protocols/rfc2616/rfc2616.html>
defines C<POST> and C<PUT> so that they're nearly interchangeable, which
is how we ended up with competing REST/CRUD API design philosophies.

Some web API designers like to use C<POST> for both create and update
operations since you can distinguish the cases based on whether the
HTTP request contains a database row ID: if so, it's a request to update
an existing record, else it's a record creation request.

That justification is fine in a web framework that defines the URL
scheme in the file system, such as PHP, ASP, or JSP since it is normal
to handle all four verbs in a single file in that sort of web framework.
In Dancer, my preferred scheme works better since it defines one route
per CRUD operation.

Although the HTTP spec defines C<PUT> and C<POST> as partially
interchangeable, you must not swap the C<PUT> and C<POST> verbs from the
way I've defined them above. The HTTP spec says
L<C<PUT> is idempotent|http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1>, meaning
that the browser is allowed to cache C<PUT> requests, suppressing
subsequent identical calls if the request parameters do not change. In
CRUD terms, this means that if you define "create" in terms of C<PUT>,
the browser might not let you create two records with identical
contents but different IDs, which means you risk losing data. The HTTP
spec does not allow browsers to assume that identical C<POST> calls are
idempotent, however, so we use that verb for CRUD's create operation,
leaving C<PUT> = update.

That's enough design philosophy; how does all that affect our Dancer
code? We might decide that since we've almost got a REST API here that
we might want to push it the rest of the way.

Let's move the CRUD-like route handlers in C<lib/App/MajorFeature.pm> to
C<lib/App/API/SubFeature.pm>, and also refine the programming interface
a bit:

    prefix '/api' => sub {
        prefix '/subfeature' => sub {
            post ''     => \&_post;
            get  ''     => \&_get;
            put  '/:id' => \&_put;
            del  '/:id' => \&_del;
        };
    };

My choice to use leading underscores in these module-internal route
handler function names lets us parallel the Dancer DSL keyword naming
scheme.

You might instead prefer to make the HTTP-to-CRUD mapping more explicit:

    prefix '/api' => sub {
        prefix '/subfeature' => sub {
            post ''     => \&_create;
            get  ''     => \&_read;
            put  '/:id' => \&_update;
            del  '/:id' => \&_delete;
        };
    };

As in the previous article in this series, the leading underscore
convention saves us some aggravation here since C<delete> is a Perl
keyword, and C<read> is a core Perl function.

The only other thing to change here is that REST APIs normally return
JSON or XML. I prefer JSON since that's directly usable by the
JavaScript code that made the Ajax call to one of these APIs. One of the
best features of Dancer is that automatic JSON encoding is built right
in. First, enable the feature by adding this to your C<config.yml> file:

    serializer: JSON

That lets us write the C<_create()> function referenced above as:

    sub _create {
        my $params = request->params;
        my $db     = get_db_conn;
    
        if ($db->create_something($params->{arg1}, $params->{arg2})) {
            return {
                success => JSON::true,
                id      => $db->last_insert_id(),
            };
        }
        else {
            return {
                success => JSON::false,
                error   => 'failed to create record: ' . $db->last_error(),
            };
        }
    }

By telling Dancer that we want unlabeled return values from route
handlers to be sent through the built-in JSON serializer, it not only
converts Perl data structures to their JSON equivalents, it also
automatically sets the the HTTP response's content type is set to
C<application/json>. Parsing and using that reply on the client side in
JavaScript is therefore trivial.

This does not interfere with the more typical C<template> return value
from route handlers, since those are labeled in such a way that they
bypass the JSON serializer. This way of returning either JSON or HTML to
the caller depending solely on whether the Dancer app uses C<template>
feels natural and effortless to me, and therefore makes the code feel
"right."

Dancer does have a way to force use of a particular serializer: the
L<C<send_as> DSL keyword|https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#send_as>.
My immediate reaction to finding a C<send_as> call in a Dancer app is to
L<wrinlke my nose|https://en.wikipedia.org/wiki/Code_smell> for the same
reason I mistrust type casts elsewhere in code. Both mechanisms force a
value from its natural data type to another one; a conscientious
developer asks whether there is a good reason to fight the default
conversion rules in each case.

If your new REST API route handlers previously returned HTML, and you
have existing code that still needs this data in HTML form, I prefer to
separate those Ajax call handlers into a different section of the URL
hierarchy: C</parts>. The rule is simple: C</api> routes return JSON,
whereas C</parts> routes return HTML fragments. Those fragments are
intended to be inserted into an existing DOM via JavaScript. The
C</parts> section of the URL hierarchy separates out such route handlers
from those that return whole HTML pages.

Sometimes you need the same data in both HTML and JSON forms. I find
that Dancer makes this easy. In the Perl module defining the
HTML-returning route, say something like this:

    package App::SubFeature
    use Dancer2 appname => 'App';

    sub _get {
        return template '/mf/subfeature' => {
            data => App::API::SubFeature::_get
        };
    }

    prefix '/mf' => sub {
        prefix '/subfeature' => sub {
            get '' => \&_get;
            # etc.
        }
    }

The key line is in the middle of the example, which calls over into the
module defining the corresponding API route handler, which looks like
this:

    package App::API::SubFeature
    use Dancer2 appname => 'App';

    sub _get {
        return {
            some => 'complicated',
            data => 'structure',
        };
    }

    prefix '/api' => sub {
        # more route defs, including one to call _get() above
    }

That is, the API side is returning a complicated Perl data structure
directly, intending that Dancer JSONify it for the caller, while a
different route handler outside the JSON API section passes that same
data structure into our C</mf/subfeature> template in order to provide
an alternative HTML rendering of the same data. The work to produce that
complicated Perl data structure only has to happen in once place even
though it is consumed as both HTML and JSON.

This pattern is common in code that needs to return an initial view of a
given data structure which is later updated via Ajax: on some
change-triggering event, the Ajax handler sends new data back to the
Dancer app and gets back an updated JSON data structure, with which it
updates the initial HTML returned by the Dancer app.

This article series concludes with a scheme for
L<hot code reloading|/2015/8>, a very useful feature in any Dancer
app, but especially helpful as your app grows larger.
