=head1 Medium-Scale Dancer, Part 2: Route Definitions

By the time a Dancer app grows large enough that you want to start
breaking it up into multiple Perl modules, as in the
L<previous article in this series|http://advent.perldancer.org/2015/3>,
you've probably also defined enough routes that you're starting to have
problems managing them all. Just as with the Perl code, Dancer lets us
break up the monolithic route definition set, too.

If you structured your app in the way recommended in the previous
article, each major feature of your web app is now in its own Perl
module. That Perl module's name likely corresponds to some part of your
app's URL scheme. Let's say you're exposing the features of
C<App::MajorFeature> as C</mf> in URLs, with sub-features underneath
that.

If you extend the generated C<lib/App.pm> file by following the simplest
examples from the Dancer documentation, you might have a mess that looks
something like this:

 get '/mf' => sub {
     # Lots of Perl code to return the top-level MajorFeature view
 };

 get '/mf/subfeature' => sub {
     # Implementation of a sub-feature of MajorFeature
 };

 post '/mf/subfeature' => sub {
     # Maybe you need a way to add new subfeature objects
 };

 put '/mf/subfeature' => sub {
     # And maybe also a way to edit existing subfeature objects
 };

 del '/mf/subfeature/:id' => sub {
     # And a way to delete them, too
 };

The first thing to fix here is that almost all of the Perl code
implementing each route handler should move to C<lib/App/*.pm>. Ideally,
each route handler body should do nothing more than call a function in
one of these modules:

 get  '/mf'                => sub { App::MajorFeature::retrieve(context); };
 get  '/mf/subfeature'     => sub { App::MajorFeature::sub_feature(context); };
 post '/mf/subfeature'     => sub { App::MajorFeature::add(context); };
 put  '/mf/subfeature'     => sub { App::MajorFeature::modify(context); };
 del  '/mf/subfeature/:id' => sub { App::MajorFeature::remove(context); };

If that still looks like a bit of a mess to you, don't worry, we'll 
continue to improve it as we go along.

The C<context()> function that I call from each of those route handlers
is a small helper that I define at global scope within the app:

 sub context {
     return {
         config  => config(),
         request => request(),
         session => session(),
         dbconn  => App::Utility::get_db_conn(),
         etc     => ...
     };
 }

It just bundles up a bunch of Dancer objects into a hash for you,
possibly along with some app-specific objects that are widely used
within your app. I find this convenient, but perhaps you prefer to use
the Dancer DSL to access each of these objects directly instead.

The URL scheme defined above is quite redundant. We can factor out that
redundancy in two stages.

First, Dancer has the awesome
L<C<prefix>|https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#prefix>
feature, which lets us express the URL hierarchy directly in the code,
without repeating elements of the URL:

 prefix '/mf' => sub {
     get '/' => sub { App::MajorFeature::retrieve(context); };
     prefix '/subfeature' => sub {
         get  '/'    => sub { App::MajorFeature::sub_feature(context); };
         post '/'    => sub { App::MajorFeature::add(context); };
         put  '/'    => sub { App::MajorFeature::modify(context); };
         del  '/:id' => sub { App::MajorFeature::remove(context); };
     };
 };

Factoring out the C</mf> part was a net loss of 1 character per route
with our 4-space indents, but factoring out C</subfeature> saved us a
net 6 characters per route, which really helps make the code easier to
read.

Rewriting your URL handlers this way will help us greatly later in this
series of articles.

A second excellent feature of Dancer lets us shorten those lines of code
still further.

So far, we've been using explicitly-qualified function names. This is
because we want to use short function names within the modules (e.g.
C<retrieve()>) without causing namespace collisions by exporting all of
the functions. But in fact, there is actually no need to expose the API
of your modules outside the module itself. Dancer doesn't care I<where>
you define the route handlers, just that they're all defined by the time
your caller wants to use them. In the previous part of this article
series, we said C<use App::MajorFeature> and such within C<lib/App.pm>,
so every one of our app's modules gets executed on startup. This means
that any code at global scope within these modules also runs at startup.

Therefore, we can move all of the route definitions above from
C<lib/App.pm> to the end of C<lib/App/MajorFeature.pm>:

 prefix '/mf' => sub {
     get '/' => sub { retrieve(context); };
     prefix '/subfeature' => sub {
         get  '/'    => sub { sub_feature(context); };
         post '/'    => sub { add(context); };
         put  '/'    => sub { modify(context); };
         del  '/:id' => sub { remove(context); };
     };
 };

Now all the function calls are made within the C<App::MajorFeature>
module, so we don't need to qualify them.

If you are using my C<context()> idea, you will have to move it out of
C<lib/App.pm>, such as into the C<App::Utility> module, exported by
default:

 package App::Utility {
     use Dancer2 appname => 'App';
 
     require Exporter;
     use base qw(Exporter);
     our @EXPORT = qw(context);
 
     sub get_db_conn {
         # do something useful here;
         # not exported, since context->{dbconn} holds our return value
     }
 
     sub context {
         return {
             config  => config(),
             request => request(),
             session => session(),
             dbconn  => get_db_conn(),
             etc     => ...
         };
     }
 }

Having done all this, all that's left behind in C<lib/App.pm> is Dancer
startup and other initialization code, such as hook definitions, as is
appropriate for the app's top-level module.

The bulk of the application's code is now collected into a set of
tightly-scoped modules. These modules should also be largely decoupled,
since only Dancer needs to know how to call into them, and you told it
how from the module itself, by defining routes. Beautiful.

In the L<next part of this series|http://advent.perldancer.org/2015/5>,
we will consider how this application restructuring affects the way we
arrange our view files.
